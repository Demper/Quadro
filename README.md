# Quadro Framework

Less is more, a lean and mean php framework
 

## Application Instance 
This is the hart of the framework and is an implementation of the Singleton Pattern. Yes I know, the Singleton
Pattern is considered an anti-pattern. Hear me out. It is the only object with this pattern, and the Application is 
implementing the Registry Pattern for all objects which should be available for the lifetime of a request.

All Objects which must be accessible in the lifetime of the Request are Components in the eyes of the Quadro Framework, 
and therefore must implement the ComponentInterface. Most off the components obviously should be added to the registry at start 
up of the request will they be available to all, but this is not required.  

The Application has a number of these components as well. 
There are a couple of system components with a default instance. In most of the cases this is enough, 
but you are free to replace them as long as these components will implement their corresponding interface(Config > ConfigInterface, 
Dispatcher > DispatcherInterface, etc.) More on these components later.

Below a sample initialization of an Applications instance.

```PHP
// simply add the following script to initialize the Quadro API framework
require_once '/path-to-quadro-api-framework/bin/init.php';

// list of aliases used in this script
use Quadro\Application as Application;
use Quadro\Config as Config;
use Quadro\Resource\Text as TextResource;
Use Quadro\Database as Db;

// get the only instance
$app = Application::getInstance();

// Adding Components
// #1 Configure the application by adding Components directly in the Registry with a closure. The closure must return an
//    object implementing the ComponentInterface if not an RegistryException is thrown 
$app->getRegistry()->add(function() {
    $config = new Config();
    $config->setOptions([
        'database' =>  'sqlite:' . realpath(Q_APPLICATION_DIR . '/__data/db.sqlite') 
    ]);
    return $config;
});

// #2 Or add through a shortcut method of the Application class.
$app->addComponent(new TextResource());

// #3 Add two of the same components by specifying the index. If not it will default to whatever the
//    function ComponentInterface::getComponentName() will return
$app->addComponent(function(){
    $config = Application::getInstance()->getComponent(Config::getComponentName());
        return new Db($config->get('database'));
    }, 'translations'
);
$app->addComponent(
    new Db('mysql:host=localhost;dbname=testdb;charset=utf8mb4', 'usernameA', 'passwordA'),
    'models'
 );

// For now we execute the run method. More on this later
$app->run();


```
## Components 
You can add as many components as you wish. No limits. In the case of a Component depending on another make sure you add 
this before using this Component. The framework has a couple of default components which it wil use if you do not specify 
others. If you overwrite or replace these components make sure these component implement their corresponding interface. 

### Quadro\Http\Request extends Component implements RequestInterface, JsonSerializable
This Component is responsible for accessing properties off the current request such as where the request came form and 
its headers. What extra data is sent with the Request etc. See the Request Interface for more info.

### Quadro\Dispatcher extends Component implements DispatcherInterface, JsonSerializable
The dispatcher takes the Request object and tries to find a Controller to handle this request and returns the data 
generated by this controller. The controller is not required to send data back but may also manipulate the response 
object directly.

The default dispatcher   




Off course we like to keep dependencies at a minimum. But we have to accept there are objects depending on other objects. A
response will be based on the request. It will depend on who or what made the request and so force. And what or how the 
request will be assembled the response depend will also on of the application. Quadro API Framework wil dispatch the 
request to a Dispatcher and pass the responsibility to this Dispatcher Component.  

## Response Component
Every request is treated as a function and as such it will return a value. This 
return value is encapsulated in the response object together with all kinds of 
information useful to the request. 

A Json representation of the Response object 
may look like the example(s) below.

```javascript
var Response = {
    "return": {
        "value": {
            "message": "Successful login.",
            "jwt": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJxdWFkcm8iLCJhdWQiOiJUSEVfQVVESUVOQ0UiLCJpYXQiOjE2MzA1Nzc1MDcsIm5iZiI6MTYzMDU3NzUxNywiZXhwIjoxNjMwNTc3NTY3LCJkYXRhIjp7ImlkIjoxLCJmaXJzdG5hbWUiOiJmaXJzdG5hbWUiLCJsYXN0bmFtZSI6Imxhc3RuYW1lIiwiZW1haWwiOiJlbWFpbCJ9fQ.u9Sha_TM56OsDRUEAx4tv8Qf1bjL2MEWzL9w3GElIUw",
            "email": "email",
            "expireAt": 1630577567
        },
        "type": "array",
        "count": 4,
        "offset": 0,
        "limit": 4,
        "total": 4
    },
    "environment": "development",
    "execution": {
        "start": "2021-09-02 10:11:47.702003",
        "end": "2021-09-02 10:11:47.704159",
        "duration": 0.002156
    },
    "status": {
        "code": 200,
        "text": "Ok"
    }
}

var Response = {
    "return": {
        "value": null,
        "type": "NULL"
    },
    "environment": "production",
    "execution": {
        "start": "2021-09-02 10:53:15.230499",
        "end": "2021-09-02 10:53:15.270482",
        "duration": 0.039982
    },
    "messages": [
        "URI \"/bogus\" Not found"
    ],
    "status": {
        "code": 404,
        "text": "Not Found"
    }
}
```
